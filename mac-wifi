#!/usr/bin/env ruby

# This script brings together several useful wifi-related functions.
#
# It is a bit of a kludge in that it calls Mac OS commands and uses
# the text output for its data. At some point I would like to replace
# that with system calls. Currently this script can break if Apple
# decides to modify the format of its output.
#
# What would be *really* nice, would be for Apple to retrofit all
# system commands to optionally output JSON and/or YAML. Some offer XML, but that
# is not convenient to use.
#
# Mac OS commands currently used are: airport, ipconfig, networksetup, security.
#
# Author: keithrbennett (on Github, GMail, Twitter)
# I am available for Ruby development, troubleshooting, training, tutoring, etc.
#
# License: MIT License


require 'shellwords'

class Command < Struct.new(:regex, :action)
end


# Helper methods unrelated to the high level logic of the program.
module LowLevelHelpers

  # Output help when requested by 'h' command, or in case of unrecognized or nonexistent command.
  def print_help
    puts "
Available commands are:

ci                      = connected to Internet (not just wifi on)?
co[nnect] network-name  - turns wifi on, connects to network-name
cy[cle]                 - turns wifi off, then on, preserving network selection
d[isconnect]            - disconnects from current network, does not turn off wifi
h[elp]                  - prints this help
i[nfo]                  - prints wifi-related information
lsp[referred]           - lists preferred (not necessarily available) networks
lsa[vailable]           - lists available networks
n[etwork_name]          - name (SSID) of currently connected network
on                      - turns wifi on
of[f]                   - turns wifi off
pa[ssword] network-name - shows password for preferred network-name
q[uit]                  - exits this program (interactive shell mode only)
r[m] network-name       - removes network-name from the preferred networks list
s[hell]                 - opens an interactive pry shell (command line only)
w[ifion]                - is the wifi on?
x[it]                   - exits this program (interactive shell mode only)

When in interactive shell mode:
    * use quotes for string parameters such as method names.
    * for pry commands, use prefix `%`.


"
  end


  # We'd like to use awesome_print if it is available, but not require it.
  # So, we try to require it, but if that fails, we fall back to using pp (pretty print).
  # Returns true if awesome_print is available (after requiring it), else false after requiring 'pp'.
  def awesome_print_available?
    if @awesome_print_available.nil?  # first time here
      begin
        require 'awesome_print'
        @awesome_print_available = true
      rescue LoadError
        require 'pp'
        @awesome_print_available = false
      end
    end

    @awesome_print_available
  end


  def fancy_puts(object)
    awesome_print_available? ? ap(object) : pp(object)
  end


  # Asserts that a command has been passed on the command line.
  def validate_command_line
    if ARGV.empty?
      puts "Syntax is: #{__FILE__} command [options]"
      print_help
      exit(-1)
    end
  end

  class OsCommandError < RuntimeError
    attr_reader :exitcode, :command, :text

    def initialize(exitcode, command, text)
      @exitcode = exitcode
      @command = command
      @text = text
    end
  end


  def run_os_command(command)
    output = `#{command} 2>&1` # join stderr with stdout
    if $?.exitstatus != 0
      raise OsCommandError.new($?.exitstatus, command, output)
    end
    if verbose_mode
      puts "\n\n#{'-' * 79}\nCommand: #{command}\n\nOutput:\n#{output}#{'-' * 79}\n\n"
    end
    output
  end


  # Pry will output the content of the method from which it was called.
  # This small method exists solely to reduce the amount of pry's output
  # that is not needed here.
  def run_pry
    binding.pry
  end


  # Parses output like the text below into a hash:
  # SSID: Pattara211
  # MCS: 5
  # channel: 7
  def colon_output_to_hash(output)
    lines = output.split("\n")
    lines.each_with_object({}) do |line, new_hash|
      key, value = line.split(': ')
      key = key.strip
      value.strip! if value
      new_hash[key] = value
    end
  end


  def verbose_mode
    /-v/.match(ENV['MAC_WIFI_OPTS'])
  end
end


class MacWifi

  include LowLevelHelpers

  AIRPORT_CMD = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport'

  SUDO_MESSAGE = "This operation may require root access. You may be asked for system login credentials."

  def initialize
    @interactive_mode = false # will be true if/when user selects shell option on command line
  end


  # Identifies the (first) wireless network hardware port in the system, e.g. en0 or en1
  def wifi_hardware_port
    @wifi_hardware_port ||= begin
      lines = run_os_command("networksetup -listallhardwareports").split("\n")
      # Produces something like this:
      # Hardware Port: Wi-Fi
      # Device: en0
      # Ethernet Address: ac:bc:32:b9:a9:9d
      #
      # Hardware Port: Bluetooth PAN
      # Device: en3
      # Ethernet Address: ac:bc:32:b9:a9:9e
      wifi_port_line_num = (0...lines.size).detect do |index|
        /: Wi-Fi$/.match(lines[index])
      end
      if wifi_port_line_num.nil?
        raise %Q{Wifi port (e.g. "en0") not found in output of: networksetup -listallhardwareports}
      else
        lines[wifi_port_line_num + 1].split(': ').last
      end
    end
  end


  def connected_to_internet?
    require 'open-uri'
    connected = false
    begin
      open('http://www.google.com')
      connected = true
    rescue
      # swallow exception; connected will remain false
    end
    connected
  end


  # Shows available wireless network, as you would see by clicking the wifi toolbar icon.
  def available_networks
    run_os_command("#{AIRPORT_CMD} -s")
  end


  # Shows "preferred" networks, many/most of which will probably not be available.
  def preferred_networks
    lines = run_os_command("networksetup -listpreferredwirelessnetworks #{wifi_hardware_port}").split("\n")
    # Produces something like this, unsorted, and with leading tabs:
    # Preferred networks on en0:
    #         LibraryWiFi
    #         @thePAD/Magma

    lines.delete_at(0)                         # remove title line
    lines.map! { |line| line.gsub("\t", '') }  # remove leading tabs
    lines.sort! { |s1, s2| s1.casecmp(s2) }    # sort alphabetically, case insensitively
    lines
  end


  # Turns wifi off and then on, reconnecting to the originally connecting network.
  def cycle_network
    network_name = current_network
    wifi_off
    wifi_on
    connect(network_name) if network_name
  end


  # Turns wifi on.
  def wifi_on
    return if wifi_on?
    output = run_os_command("networksetup -setairportpower #{wifi_hardware_port} on")
    raise "Wifi could not be enabled." unless wifi_on?
    output
  end


  # Turns wifi off.
  def wifi_off
    return unless wifi_on?
    output = run_os_command("networksetup -setairportpower #{wifi_hardware_port} off")
    raise "Wifi could not be enabled." if wifi_on?
    output
  end


  def connected_network_name
    wifi_info['SSID']
  end


  def connected_to?(network_name)
    raise "Wifi not enabled." unless wifi_on?
    network_name == connected_network_name
  end


  # Connects to the passed network name, optionally with password.
  # Turns wifi on first, in case it was turned off.
  def connect(network_name, password = nil)
    if network_name.nil? || network_name.empty?
      raise "A network name is required but was not provided."
    end
    wifi_on
    command = "networksetup -setairportnetwork #{wifi_hardware_port} " + "#{Shellwords.shellescape(network_name)}"
    if password
      command << ' ' << Shellwords.shellescape(password)
    end
    run_os_command(command)
    # Verify that the network is now connected:
    unless connected_network_name == network_name
      connected_network_name; exit(0)
      message = "Expected to connect to #{network_name} but connected to #{connected_network_name} instead. "
      message << (password ? "Did you provide the correct password?" : "Did you need to provide a password?")
      raise message
    end
    nil
  end


  def preferred_network_password(preferred_network_name)
    if preferred_networks.include?(preferred_network_name)
      command = %Q{security find-generic-password -D "AirPort network password" -a #{preferred_network_name} -w 2>&1}
      puts SUDO_MESSAGE
      output = nil
      begin
        output = run_os_command(command).chomp
      rescue OsCommandError => error
        if error.exitcode == 44 # network has no password stored
          nil
        else
          output
        end
      end
    else
      raise "Network #{preferred_network_name} not in preferred networks list."
    end
  end



  # Returns the IP address assigned to the wifi port, or nil if none.
  def ip_address
    begin
      run_os_command("ipconfig getifaddr #{wifi_hardware_port}").chomp
    rescue OsCommandError => error
      if error.exitcode == 1
        nil
      else
        raise
      end
    end
  end


  # Removes the specified network from the preferred network list.
  def remove_preferred_network(*network_names)

    missing_names = network_names.reject { |n| preferred_networks.include?(n) }
    if missing_names.any?
      puts "The following networks were not in the preferred networks list and do not need to be removed:"
      puts missing_names
      return if missing_names == network_names
    end

    puts SUDO_MESSAGE

    if network_names.empty?
      puts "No names provided."
      raise "Must provide 1 or more network names to remove."
    end

    network_names.each do |name|
      run_os_command("sudo networksetup -removepreferredwirelessnetwork " +
          "#{wifi_hardware_port} #{Shellwords.shellescape(name)}")
    end
  end


  # Returns true if wifi is on, else false.
  def wifi_on?
    lines = run_os_command("#{AIRPORT_CMD} -I").split("\n")
    ! lines.grep("AirPort: Off").any?
  end


  # Returns the network currently connected to, or nil if none.
  def current_network
    lines = run_os_command("#{AIRPORT_CMD} -I").split("\n")
    ssid_lines = lines.grep(/ SSID:/)
    ssid = ssid_lines.first.split('SSID: ').last.strip
    ssid.empty? ? nil : ssid
  end


  # Disconnects from the currently connected network. Does not turn off wifi.
  def disconnect
    puts SUDO_MESSAGE
    run_os_command("sudo #{AIRPORT_CMD} -z")
  end


  # Outputs some useful wifi-related information.
  def wifi_info

    info = {
        wifi_on:     wifi_on?,
        internet_on: connected_to_internet?,
        port:        wifi_hardware_port,
        network:     current_network,
        ip_address:  ip_address,
    }
    more_output = run_os_command(AIRPORT_CMD + " -I")
    more_info   = colon_output_to_hash(more_output)
    info.merge!(more_info)
    info.delete('AirPort') # will be here if off, but info is already in wifi_on key
    info
  end


  # Runs a pry session in the context of this object.
  # Commands and options specified on the command line can also be specified in the shell.
  def run_shell
    if @interactive_mode
      puts "Already in shell."
      return
    end

    @interactive_mode = true

    begin
      require 'pry'
    rescue LoadError
      puts "The 'pry' gem, required for running the shell, was not found. Please `gem install pry`."
      exit(-1)
    end

    print_help

    # Enable the line below if you have any problems with pry configuration being loaded
    # that is messing up this runtime use of pry:
    # Pry.config.should_load_rc = false

    # Strangely, this is the only thing I have found that successfully suppresses the
    # code context output, which is not useful here. Anyway, this will differentiate
    # a pry command from a DSL command, which _is_ useful here.
    Pry.config.command_prefix = '%'

    run_pry
  end


  # For use by the shell; when typing a command and options, it is passed to process_command_line
  def method_missing(method_name, *options)
    method_valid = !! find_command_action(method_name)
    if method_valid
      process_command_line(method_name, options)
    else
      raise NoMethodError.new(
          %Q{"#{method_name}" is not a valid command. If you intend for this to be a string literal, use quotes.},
          method_name)
    end
  end


  def output_network_password(network_name, password)
    if password
      puts %Q{Preferred network "#{network_name}" stored password is: #{%Q{"#{password}"}}}
    else
      puts %Q{Preferred network "#{network_name}" has no stored password.}
    end
  end


  # Processes the command (ARGV[0]) and any relevant options (ARGV[1..-1]).
  #
  # CAUTION! In interactive mode, any strings entered (e.g. a network name) MUST
  # be in a form that Ruby will recognize as a string, i.e. single or double quotes,
  # %q, %Q, etc. Otherwise Ruby will assume it's a method name and pass it to
  # method_missing!
  def process_command_line(command, options)
    action = find_command_action(command)
    if action
      action.(*options)
    else
      print_help
      raise "Unrecognized command. Command was #{action} and options were #{options.inspect}."
    end
  end


  def quit
    if @interactive_mode
      exit(0)
    else
      puts "This command can only be run in shell mode."
    end
  end


  def commands
    @commands_ ||= [
        Command.new(/^ci/,  -> (*_options) { puts "Connected to Internet: #{connected_to_internet?}" }),
        Command.new(/^co/,  -> (*options)  { connect(options[0], options[1]); nil }),
        Command.new(/^cy/,  -> (*_options) { cycle_network; nil }),
        Command.new(/^d/,   -> (*_options) { disconnect; nil }),
        Command.new(/^h/,   -> (*_options) { print_help; nil }),
        Command.new(/^i/,   -> (*_options) { fancy_puts(wifi_info); nil }),
        Command.new(/^lsa/, -> (*_options) { puts available_networks }),
        Command.new(/^lsp/, -> (*_options) { puts preferred_networks }),
        Command.new(/^n/,   -> (*_options) { puts connected_network_name }),
        Command.new(/^of/,  -> (*_options) { wifi_off; nil }),
        Command.new(/^on/,  -> (*_options) { wifi_on; nil }),
        Command.new(/^pa/,  -> (*options)  { puts; puts "options is a #{options.class} of size #{options.size}; first is #{options.first.class}"; p options; puts; network = options.first; output_network_password(network, preferred_network_password(network)); nil }),
        Command.new(/^q/,   -> (*_options) { quit() }),
        Command.new(/^r/,   -> (*options)  { remove_preferred_network(*options); nil }),
        Command.new(/^s/,   -> (*_options) { run_shell; nil }),
        Command.new(/^w/,   -> (*_options) { puts "Wifi on?: #{wifi_on?}" }),
        Command.new(/^x/,   -> (*_options) { quit() })
    ]
  end


  def find_command_action(command_string)
    result = commands.detect { |cmd| cmd.regex.match(command_string) }
    result ? result.action : nil
  end


  def call
    validate_command_line
    process_command_line(ARGV[0], ARGV[1..-1])
  end

end


# puts "\nLowLevelHelpers methods:\n\n"
# puts LowLevelHelpers.instance_methods(false).sort
#
# puts "\nMacWifi methods:\n\n"
# puts MacWifi.instance_methods(false).sort


MacWifi.new.call
# or MacWifi.new.()

