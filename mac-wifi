#!/usr/bin/env ruby

# This script brings together several useful wifi-related functions.
#
# It is a bit of a kludge in that it calls Mac OS commands and uses
# the text output for its data. At some point I would like to replace
# that with system calls. Currently this script can break if Apple
# decides to modify the format of its output.
#
# What would be *really* nice, would be for Apple to retrofit all
# system commands to optionally output JSON and/or YAML. Some offer XML, but that
# is not convenient to use.
#
# Mac OS commands currently used are: airport, ipconfig, networksetup, security.
#
# Author: keithrbennett (on Github, GMail, Twitter)
# I am available for Ruby development, troubleshooting, training, tutoring, etc.
#
# License: MIT License


require 'shellwords'

# Helper methods unrelated to the high level logic of the program.
module LowLevelHelpers

  # Output help when requested by 'h' command, or in case of unrecognized or nonexistent command.
  def print_help
    puts "
Available commands are:

co[nnect] network-name  - turns wifi on, connects to network-name
cy[cle]                 - turns wifi off, then on
d[isconnect]            - disconnects from current network, does not turn off wifi
h[elp]                  - prints this help
i[nfo]                  - prints wifi-related information
lsp[referred]           - lists preferred (not necessarily available) networks
lsa[vailable]           - lists available networks
on                      - turns wifi on
of[f]                   - turns wifi off
p[assword] network-name - shows password for preferred network-name
q[uit]                  - exits this program (interactive shell mode only)
r[m] network-name       - removes network-name from the preferred networks list
s[hell]                 - opens an interactive pry shell (command line only)
x[it]                   - exits this program (interactive shell mode only)

"
  end


  # We'd like to use awesome_print if it is available, but not require it.
  # So, we try to require it, but if that fails, we fall back to using pp (pretty print).
  # Returns true if awesome_print is available (after requiring it), else false after requiring 'pp'.
  def awesome_print_available?
    begin
      require 'awesome_print'
      true
    rescue LoadError
      require 'pp'
      false
    end
  end


  # Asserts that a command has been passed on the command line.
  def validate_command_line
    if ARGV.empty?
      puts "Syntax is: #{__FILE__} command [options]"
      print_help
      exit(-1)
    end
  end


  def run_os_command(command)
    output = `#{command} 2>&1` # join stderr with stdout
    if $?.exitstatus != 0
      raise "Error #{$?.exitstatus} on command: #{command}\nOutput was:\n#{output}"
    end
    output
  end


  # Pry will output the content of the method from which it was called.
  # This small method exists solely to reduce the amount of pry's output
  # that is not needed here.
  def run_pry
    binding.pry
  end
end


class MacWifi

  include LowLevelHelpers

  AIRPORT_CMD = '/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport'

  SUDO_MESSAGE = "This operation may require root access. You may be asked for system login credentials."

  def initialize
    @interactive_mode = false # will be true if/when user selects shell option on command line
  end


  # Identifies the (first) wireless network hardware port in the system, e.g. en0 or en1
  def wifi_hardware_port
    @wifi_hardware_port ||= begin
      lines = run_os_command("networksetup -listallhardwareports").split("\n")
      # Produces something like this:
      # Hardware Port: Wi-Fi
      # Device: en0
      # Ethernet Address: ac:bc:32:b9:a9:9d
      #
      # Hardware Port: Bluetooth PAN
      # Device: en3
      # Ethernet Address: ac:bc:32:b9:a9:9e
      wifi_port_line_num = (0...lines.size).detect do |index|
        /: Wi-Fi$/ === lines[index]
      end
      if wifi_port_line_num.nil?
        raise %Q{Wifi port (e.g. "en0") not found in output of: networksetup -listallhardwareports}
      else
        lines[wifi_port_line_num + 1].split(': ').last
      end
    end
  end


  # Shows available wireless network, as you would see by clicking the wifi toolbar icon.
  def available_networks
    run_os_command("#{AIRPORT_CMD} -s")
  end


  # Shows "preferred" networks, many/most of which will probably not be available.
  def preferred_networks
    lines = run_os_command("networksetup -listpreferredwirelessnetworks #{wifi_hardware_port}").split("\n")
    # Produces something like this, unsorted, and with leading tabs:
    # Preferred networks on en0:
    #         LibraryWiFi
    #         @thePAD/Magma

    lines.delete_at(0)                         # remove title line
    lines.map! { |line| line.gsub("\t", '') }  # remove leading tabs
    lines.sort! { |s1, s2| s1.casecmp(s2) }    # sort alphabetically, case insensitively
    lines
  end


  # Turns wifi off and then on, reconnecting to the originally connecting network.
  def cycle_network
    network_name = current_network
    wifi_off
    wifi_on
    connect(network_name) if network_name
  end


  # Turns wifi on.
  def wifi_on
    run_os_command("networksetup -setairportpower #{wifi_hardware_port} on")
  end


  # Turns wifi off.
  def wifi_off
    run_os_command("networksetup -setairportpower #{wifi_hardware_port} off")
  end


  # Connects to the passed network name, optionally with password.
  # Turns wifi on first, in case it was turned off.
  def connect(network_name, password = nil)

    if network_name.nil? || network_name.empty?
      raise "A network name is required but was not provided."
    end

    wifi_on

    command = "networksetup -setairportnetwork #{wifi_hardware_port} " + "#{Shellwords.shellescape(network_name)}"
    if password
      command << ' ' << Shellwords.shellescape(password)
    end

    run_os_command(command)
  end


  def preferred_network_password(preferred_network_name)
    if preferred_networks.include?(preferred_network_name)
      command = %Q{security find-generic-password -D "AirPort network password" -a #{preferred_network_name} -w 2>&1}
      puts SUDO_MESSAGE
      output = `#{command}`.chomp
      network_has_no_password = ($?.exitstatus == 44)
      network_has_no_password ? nil : output
    else
      raise "Network #{preferred_network_name} not in preferred networks list."
    end
  end



  # Returns the IP address assigned to the wifi port, or nil if none.
  def ip_address
    run_os_command("ipconfig getifaddr #{wifi_hardware_port}").chomp
  end


  # Removes the specified network from the preferred network list.
  def remove_preferred_network(*network_names)

    missing_names = network_names.reject { |n| preferred_networks.include?(n) }
    if missing_names.any?
      raise 'x'
      puts "The following networks were not in the preferred networks list and do not need to be removed:"
      puts missing_names
      return if missing_names == network_names
    end

    puts SUDO_MESSAGE

    if network_names.empty?
      puts "No names provided."
      raise "Must provide 1 or more network names to remove."
    end

    network_names.each do |name|
      run_os_command("sudo networksetup -removepreferredwirelessnetwork " +
          "#{wifi_hardware_port} #{Shellwords.shellescape(name)}")
    end
  end


  # Returns true if wifi is on, else false.
  def wifi_on?
    lines = run_os_command("#{AIRPORT_CMD} -I").split("\n")
    ! lines.grep("AirPort: Off").any?
  end


  # Returns the network currently connected to, or nil if none.
  def current_network
    lines = run_os_command("#{AIRPORT_CMD} -I").split("\n")
    ssid_lines = lines.grep(/ SSID:/)
    ssid_lines.empty? ? nil : ssid_lines.first.split('SSID: ').last
  end


  # Disconnects from the currently connected network. Does not turn off wifi.
  def disconnect
    puts SUDO_MESSAGE
    run_os_command("sudo #{AIRPORT_CMD} -z")
  end


  # Outputs some useful wifi-related information.
  def output_info
    info = {
        wifi_on:     wifi_on?,
        port:        wifi_hardware_port,
        network:     current_network,
        ip_address:  ip_address,
    }
    awesome_print_available? ? ap(info) : pp(info)
  end


  # Runs a pry session in the context of this object.
  # Commands and options specified on the command line can also be specified in the shell.
  def run_shell
    if @interactive_mode
      puts "Already in shell."
      return
    end

    @interactive_mode = true

    begin
      require 'pry'
    rescue LoadError
      puts "The 'pry' gem, required for running the shell, was not found. Please `gem install pry`."
      exit(-1)
    end

    print_help

    # Enable the line below if you have any problems with pry configuration being loaded
    # that is messing up this runtime use of pry:
    # Pry.config.should_load_rc = false

    # Strangely, this is the only thing I have found that successfully suppresses the
    # code context output, which is not useful here. Anyway, this will differentiate
    # a pry command from a DSL command, which _is_ useful here.
    Pry.config.command_prefix = '%'

    puts "For pry commands, please use prefix '%'.\n\n"
    run_pry
  end


  # For use by the shell; when typing a command and options, it is passed to process_command_line
  def method_missing(method_name, *options)
    # puts "name: #{method_name}, options: #{options.join(', ')}"
    process_command_line(method_name, options)
  end


  # Processes the command (ARGV[0]) and any relevant options (ARGV[1..-1]).
  def process_command_line(command, options)

    quit = -> do
      if @interactive_mode
        exit(0)
      else
        puts "This command can only be run in shell mode."
      end
    end

    case command
      when /^co/
        connect(options.first)
      when /^cy/
        cycle_network
      when /^d/
        disconnect
      when /^h/
        print_help
      when /^i/
        output_info
      when /^lsa/
        puts available_networks
      when /^lsp/
        puts preferred_networks
      when /^of/
        wifi_off
      when /^on/
        wifi_on
      when /^p/
        password = preferred_network_password(options.first)
        password = password ? %Q{"#{password}"} : '[nil]'
        puts %Q{Preferred network "#{options.first}" password is: #{password}}
      when /^q/
        quit.()
      when /^r/
        remove_preferred_network(*options)
      when /^s/
        run_shell
      when /^x/
        quit.()
      else
        print_help
        raise "Unrecognized command. Command was #{command} and options were #{options.inspect}."
    end
  end


  def call
    validate_command_line
    process_command_line(ARGV[0], ARGV[1..-1])
  end

end


# puts "\nLowLevelHelpers methods:\n\n"
# puts LowLevelHelpers.instance_methods(false).sort
#
# puts "\nMacWifi methods:\n\n"
# puts MacWifi.instance_methods(false).sort


MacWifi.new.call
# or MacWifi.new.()

